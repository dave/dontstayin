using System;
using System.Collections.Generic;
using System.Text;
using System.Runtime.Remoting.Lifetime;
using System.Security.Permissions;

namespace ChatLibrary
{
	[Serializable]
	public class User 
	{

		public User(ChatServer.StatusDelegate status, int usrK, ChatServer server)
		{
			Status = status;
			Server = server;
			UsrK = usrK;

			responseBuilder = new StringBuilder();
			itemCache = new List<ChatItemHolder>();
			lastRequest = DateTime.Now;
			rooms = new Dictionary<Guid, ChatRoom>();

			if (System.Environment.MachineName == "SOLO")
				Online = true;
			else
				Online = false;

			if (System.Environment.MachineName == "SOLO")
				timeoutMins = 1;
			else
				timeoutMins = 15;
		}

		#region MakeOnline
		/// <summary>
		/// Makes the user online. If ther user was not online before, we populate the cache with latest messages from all rooms.
		/// </summary>
		public void MakeOnline()
		{
			if (Online)
				return;
			
			lock (itemCache)
			{
				if (Online)
					return;

				Status("Making online...", false);
				
				Online = true;

				lock (rooms)
				{
					foreach (ChatRoom r in rooms.Values)
					{
						r.UpdateUserWithLatestPosts(this);
					}
				}
			}
			
		}
		/// <summary>
		/// Is the user online? If not, we don't populate it's cache as new messages arrive.
		/// </summary>
		public bool Online { get; set; }
		#endregion

		#region UsrK
		/// <summary>
		/// The UsrK of this user
		/// </summary>
		public int UsrK { get; set; }
		#endregion

		#region SessionID
		/// <summary>
		/// The session ID integer, generated by the client on the first request. This is used to unsure the user doesn't have multiple browser windows open
		/// </summary>
		public int SessionID { get; set; }
		#endregion

		#region IsTrash
		/// <summary>
		/// After [timeoutMins] minutes of inactivity, we expire this user
		/// </summary>
		public bool IsTrash
		{
			get
			{
				return DateTime.Now - lastRequest > TimeSpan.FromMinutes(timeoutMins);
			}
		}
		#endregion
		#region lastRequest
		/// <summary>
		/// Ticks of the last request
		/// </summary>
		DateTime lastRequest;
		#endregion
		#region timeoutMins
		/// <summary>
		/// After 15 minutes of inactivity, this user is dropped from all rooms and deleted
		/// </summary>
		int timeoutMins;
		#endregion

		#region Status
		/// <summary>
		/// Status delegate used for logging
		/// </summary>
		public ChatServer.StatusDelegate Status { get; set; }
		#endregion

		#region Server
		/// <summary>
		/// Link back to the server object
		/// </summary>
		public ChatServer Server { get; set; }
		#endregion

		#region itemCache
		/// <summary>
		/// Cache of the immediate items
		/// </summary>
		List<ChatItemHolder> itemCache { get; set; }
		#endregion

		#region responseBuilder
		/// <summary>
		/// Stringbuilder used for building responses
		/// </summary>
		StringBuilder responseBuilder { get; set; }
		#endregion

		#region rooms
		/// <summary>
		/// rooms that this user is registered with
		/// </summary>
		Dictionary<Guid, ChatRoom> rooms { get; set; }
		#endregion

		#region AddRoom
		/// <summary>
		/// Don't call this directly - it should only be called from Room.Register
		/// </summary>
		/// <param name="room"></param>
		public void AddRoom(ChatRoom room)
		{
			lock (rooms)
			{
				if (rooms.ContainsKey(room.RoomGuid))
					return;

				rooms.Add(room.RoomGuid, room);
			}
		}
		#endregion
		#region RemoveRoom
		/// <summary>
		/// Don't call this directly - it should only be called from Room.UnRegister
		/// </summary>
		/// <param name="room"></param>
		public void RemoveRoom(ChatRoom room)
		{
			if (rooms.ContainsKey(room.RoomGuid))
			{
				lock (rooms)
				{
					rooms.Remove(room.RoomGuid);
				}
			}
		}
		#endregion

		public void RemoveFromAllRooms()
		{
			lock (rooms)
			{
				lock (rooms.Values)
				{
					foreach (ChatRoom room in rooms.Values)
						room.UnRegister(this, false);
				}
			}
		}

		#region DisableAllItems
		/// <summary>
		/// This disables all items from a particular room in the cache. We don't want to remove the items from the cache, because we still want the LastItemIDs to be present.
		/// </summary>
		public void DisableAllItems(Guid roomGuid)
		{
			lock (itemCache)
			{
				if (itemCache.Count > 0)
				{
					for (int i = 0; i < itemCache.Count; i++)
					{
						if (itemCache[i].RoomGuid == roomGuid)
						{
							// We don't want to remove any items because if the latestItemID = one we remove, we 
							// will deliver the whole cache on the next refresh.
							ChatItemHolder item = itemCache[i];
							item.Disabled = true;
							itemCache[i] = item;
						}
					}
				}
			}
		}
		#endregion

		#region Update
		/// <summary>
		/// Adds an item to the cache, tweaks the item guid to ensure it's unique (we might be adding the same item twice)
		/// </summary>
		public void Update(string item, Guid itemGuid, Guid roomGuid, DateTime dateTime)
		{
			if (!Online)
				return;

			Update(new ChatItemHolder(item, itemGuid, Server.TweakGuid(itemGuid), roomGuid, dateTime));
		}
		/// <summary>
		/// Adds an item to the cache directly
		/// </summary>
		public void Update(ChatItemHolder chatItem)
		{
			if (!Online)
				return;

			lock (itemCache)
			{
				try
				{
					itemCache.Add(chatItem);
				}
				catch (Exception ex)
				{
					Status(ex.ToString(), true);
				}
			}
			cleanOutIfNeeded();
		}
		#endregion

		#region cleanOutIfNeeded
		/// <summary>
		/// Truncates the cache. Removes all items over [timeoutMins] old, and leaves the top [GlobalMaxItems] items from each room.
		/// Only fires if more than 100 items have been added since the last clean out.
		/// </summary>
		void cleanOutIfNeeded()
		{
			itemsAddedSinceLastCleanOut++;

			if (itemsAddedSinceLastCleanOut > 100)
			{
				lock (itemCache)
				{
					if (itemsAddedSinceLastCleanOut > 100)
					{
						Status("Cleaning out now...", false);

						Dictionary<Guid, int> rooms = new Dictionary<Guid, int>();

						for (int i = itemCache.Count - 1; i >= 0; i--)
						{
							if (itemCache[i].DateTime < DateTime.Now.AddMinutes(0 - timeoutMins))
							{
								itemCache.RemoveAt(i);
							}
							else
							{
								if (!rooms.ContainsKey(itemCache[i].RoomGuid))
								{
									rooms[itemCache[i].RoomGuid] = 1;
								}
								else
								{
									if (rooms[itemCache[i].RoomGuid] >= ChatServer.GlobalMaxItems)
										itemCache.RemoveAt(i);
									else
										rooms[itemCache[i].RoomGuid]++;
								}
							}

						}

						itemsAddedSinceLastCleanOut = 0;
					}
				}
			}
		}
		#endregion
		#region itemsAddedSinceLastCleanOut
		/// <summary>
		/// Number of items added to the cache since the last clean out. Clean-out trims the cache to [GlobalMaxItems] items per room.
		/// </summary>
		int itemsAddedSinceLastCleanOut;
		#endregion

		#region GetItems(Guid latestItemGuid, ref Guid newestItemGuid, ChatRoom roomToReturnInFullAndExclude)
		/// <summary>
		/// Gets the latest items in the cache, up to [latestItemGuid].
		/// If we specify [roomToReturnInFullAndExclude], we first append all items from that room, and exclude items from that room in the cache items
		/// </summary>
		public string GetItems(Guid latestItemGuid, ref Guid newestItemGuid, ChatRoom roomToReturnInFullAndExclude)
		{
			Status("User.GetItems", false);

			bool excludeRoom = roomToReturnInFullAndExclude != null;

			lastRequest = DateTime.Now;

			string output = string.Empty;
			lock (responseBuilder)
			{
				//clear the response builder
				responseBuilder.Length = 0;

				if (roomToReturnInFullAndExclude != null)
				{
					Guid g = Guid.Empty;
					roomToReturnInFullAndExclude.AppendItems(true, Guid.Empty, ref g, ChatServer.GlobalMaxItems, responseBuilder);
				}

				lock (itemCache)
				{
					if (itemCache.Count > 0)
					{
						//set the latest message id to pass back by ref
						newestItemGuid = itemCache[itemCache.Count - 1].UniqueItemGuid;

						int i = 0;

						if (latestItemGuid != Guid.Empty)
						{
							i = itemCache.Count - 1;

							//find the value of i to start building from
							while (i >= 0 && itemCache[i].UniqueItemGuid != latestItemGuid)
							{
								i--;
							}

							//increment i because we already have the message at position i
							i++;
						}

						//build the response from the remaining items
						for (; i < itemCache.Count; i++)
						{
							if (itemCache[i].Disabled)
								continue;

							if (excludeRoom && itemCache[i].RoomGuid == roomToReturnInFullAndExclude.RoomGuid)
								continue;

							if (responseBuilder.Length > 0)
								responseBuilder.Append(",");

							responseBuilder.Append(itemCache[i].Item);
						}

						output = responseBuilder.ToString();

						//clear the response builder
						responseBuilder.Length = 0;

					}
				}
			}

			return output;
		}
		#endregion
		#region GetItems(ref Guid newestItemGuid)
		/// <summary>
		/// Gets all items from the cache
		/// </summary>
		public string GetItems(ref Guid newestItemGuid)
		{
			return GetItems(Guid.Empty, ref newestItemGuid, null);
		}
		#endregion

		#region ToString()
		/// <summary>
		/// String reprasentation of the user
		/// </summary>
		/// <returns></returns>
		public override string ToString()
		{
			StringBuilder userDetails = new StringBuilder();

			userDetails.AppendFormat("\nUsrK  : {0}", UsrK);

			return userDetails.ToString();
		}
		#endregion


	}

	public struct ChatItemHolder
	{
		public ChatItemHolder(string item, Guid itemGuid, Guid uniqueItemGuid, Guid roomGuid, DateTime dateTime)
		{
			Item = item;
			ItemGuid = itemGuid;
			UniqueItemGuid = uniqueItemGuid;
			RoomGuid = roomGuid;
			DateTime = dateTime;
			Disabled = false;
		}
		#region fields
		public string Item;
		public Guid ItemGuid;
		public Guid UniqueItemGuid;
		public Guid RoomGuid;
		public DateTime DateTime;
		public bool Disabled;
		#endregion
	}
}
